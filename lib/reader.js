// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, PATH, add_comments_to_intervals, alert, append_tag, badge, debug, echo, extras_range_pattern, help, info, interval_from_block_name, interval_from_range_match, interval_from_rsg, log, resolve, resolve_extras, resolve_ucd, rpr, step, ucd_range_pattern, urge, warn, whisper;

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'NCR-UNICODE-CACHE-WRITER/READER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  require('pipedreams/lib/plugin-tsv');

  step = require('coffeenode-suspend').step;

  ucd_range_pattern = /^([0-9a-f]{4,6})\.\.([0-9a-f]{4,6});[\x20\t]+(.+)$/i;

  extras_range_pattern = /^\^([0-9a-f]{1,6})(?:\.\.([0-9a-f]{1,6}))?$/i;

  resolve = function(path) {
    return PATH.resolve(__dirname, '..', path);
  };

  resolve_ucd = function(path) {
    return resolve(PATH.join('Unicode-UCD-9.0.0', path));
  };

  resolve_extras = function(path) {
    return resolve(PATH.join('extras', path));
  };

  interval_from_block_name = function(S, rsg, block_name) {
    var R;
    if ((R = S.interval_by_names[block_name]) == null) {
      throw new Error("RSG " + rsg + ": unknown Unicode block " + (rpr(block_name)));
    }
    return R;
  };

  interval_from_rsg = function(S, rsg) {
    var R;
    if ((R = S.interval_by_rsgs[rsg]) == null) {
      debug('4020', S.interval_by_rsgs);
      throw new Error("unknown RSG " + (rpr(rsg)));
    }
    return R;
  };

  add_comments_to_intervals = function(S) {
    var comment, hex, hi, i, interval, len, lo, ref, ref1;
    hex = function(n) {
      return 'U+' + n.toString(16);
    };
    ref = S.intervals;
    for (i = 0, len = ref.length; i < len; i++) {
      interval = ref[i];
      lo = interval.lo, hi = interval.hi;
      comment = (ref1 = interval['comment']) != null ? ref1 : '';
      interval['comment'] = ("(" + (hex(lo)) + ".." + (hex(hi)) + ") " + comment).trim();
    }
    return null;
  };

  interval_from_range_match = function(S, match) {
    var _, hi, hi_hex, lo, lo_hex;
    _ = match[0], lo_hex = match[1], hi_hex = match[2];
    lo = parseInt(lo_hex, 16);
    hi = (hi_hex != null) && hi_hex.length > 0 ? parseInt(hi_hex, 16) : lo;
    return {
      lo: lo,
      hi: hi
    };
  };

  append_tag = function(S, interval, tag) {
    var target;
    if ((target = interval['tag']) != null) {
      if (CND.isa_list(target)) {
        target.push(tag);
      } else {
        interval['tag'] = [target, tag];
      }
    } else {
      interval['tag'] = [tag];
    }
    return null;
  };

  this.$show = (function(_this) {
    return function(S) {
      return $(function(x) {
        return urge(JSON.stringify(x));
      });
    };
  })(this);

  this.$split_multi_blank_sv = function(S) {
    return D.$split_tsv({
      splitter: /\t{1,}|[\x20\t]{2,}/g
    });
  };

  this.read_block_names = function(S, handler) {
    var input, path, type;
    path = resolve_ucd('Blocks.txt');
    input = D.new_stream({
      path: path
    });
    type = 'block';
    S.interval_by_names = {};
    input.pipe(D.$split_tsv()).pipe(this.$block_interval_from_line(S)).pipe($((function(_this) {
      return function(interval) {
        var name;
        name = interval["" + type];
        S.interval_by_names[name] = interval;
        return S.intervals.push(interval);
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.$block_interval_from_line = (function(_this) {
    return function(S) {
      var type;
      type = 'block';
      return $(function(arg, send) {
        var _, hi, hi_hex, line, lo, lo_hex, match, name, obj, short_name;
        line = arg[0];
        match = line.match(ucd_range_pattern);
        if (match == null) {
          return send.error(new Error("not a valid line: " + (rpr(line))));
        }
        _ = match[0], lo_hex = match[1], hi_hex = match[2], short_name = match[3];
        lo = parseInt(lo_hex, 16);
        hi = parseInt(hi_hex, 16);
        name = type + ":" + short_name;
        return send((
          obj = {
            lo: lo,
            hi: hi,
            name: name,
            type: type
          },
          obj["" + type] = short_name,
          obj
        ));
      });
      return null;
    };
  })(this);

  this.read_assigned_codepoints = function(S, handler) {
    var input, path;
    path = resolve_ucd('UnicodeData.txt');
    input = D.new_stream({
      path: path
    });
    input.pipe(D.$split_tsv({
      splitter: ';'
    })).pipe($((function(_this) {
      return function(fields, send) {
        return send([fields[0], fields[1]]);
      };
    })(this))).pipe($((function(_this) {
      return function(arg, send) {
        var cid_hex, name;
        cid_hex = arg[0], name = arg[1];
        return send([parseInt(cid_hex, 16), name]);
      };
    })(this))).pipe(this.$collect_intervals(S)).pipe($((function(_this) {
      return function(arg, send) {
        var hi, lo;
        lo = arg.lo, hi = arg.hi;
        return send({
          lo: lo,
          hi: hi,
          tag: '-unassigned assigned'
        });
      };
    })(this))).pipe($('start', (function(_this) {
      return function(send) {
        return send({
          lo: 0x000000,
          hi: 0x10ffff,
          tag: 'unassigned'
        });
      };
    })(this))).pipe($((function(_this) {
      return function(interval) {
        return S.intervals.push(interval);
      };
    })(this))).pipe($('finish', (function(_this) {
      return function() {
        return handler();
      };
    })(this)));
    return null;
  };

  this.$collect_intervals = function(S) {
    var last_cid, last_hi, last_interval_start, last_lo;
    last_interval_start = null;
    last_cid = null;
    last_lo = null;
    last_hi = null;
    return $('null', (function(_this) {
      return function(entry, send) {
        var cid, hi, lo, name;
        if (entry != null) {
          cid = entry[0], name = entry[1];
          if ((name !== '<control>') && (name.startsWith('<'))) {

            /* Explicit ranges are marked by `<XXXXX, First>` for the first and `<XXXXX, Last>` for the last
            CID; these can be dealt with in a simplified manner:
             */
            if (name.endsWith('First>')) {
              if (last_interval_start != null) {
                return send.error(new Error("unexpected start of range " + (rpr(name))));
              }
              last_interval_start = cid;
            } else if (name.endsWith('Last>')) {
              if (last_interval_start == null) {
                return send.error(new Error("unexpected end of range " + (rpr(name))));
              }
              lo = last_interval_start;
              last_interval_start = null;
              hi = cid;
              send({
                lo: lo,
                hi: hi
              });
            } else {

              /* Any entry whose name starts with a `<` (less-than sign) should either have the symbolic
              name of '<control>' or else demarcate a range boundary; everything else is an error:
               */
              return send.error(new Error("unexpected name " + (rpr(name))));
            }
          } else {

            /* Single point entries */

            /* TAINT Code duplication with `INTERVALSKIPLIST.intervals_from_points` */
            if (last_lo == null) {
              last_lo = cid;
              last_hi = cid;
              last_cid = cid;
              return null;
            }
            if (cid === last_cid + 1) {
              last_hi = cid;
              last_cid = cid;
              return null;
            }
            send({
              lo: last_lo,
              hi: last_hi
            });
            last_lo = cid;
            last_hi = cid;
            last_cid = cid;
          }
        } else {
          if ((last_lo != null) && (last_hi != null)) {
            send({
              lo: last_lo,
              hi: last_hi
            });
          }
          send(null);
        }
        return null;
      };
    })(this));
  };

  this.read_planes_and_areas = function(S, handler) {
    var input, path;
    path = resolve_extras('planes-and-areas.txt');
    input = D.new_stream({
      path: path
    });
    input.pipe(this.$split_multi_blank_sv(S)).pipe(this.$read_target_interval(S)).pipe($((function(_this) {
      return function(arg) {
        var hi, interval, lo, name, obj, ref, short_name, type;
        (ref = arg[0], lo = ref.lo, hi = ref.hi), type = arg[1], short_name = arg[2];
        name = type + ":" + short_name;
        interval = (
          obj = {
            lo: lo,
            hi: hi,
            name: name,
            type: type
          },
          obj["" + type] = short_name,
          obj
        );
        return S.intervals.push(interval);
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.$read_target_interval = (function(_this) {
    return function(S) {
      return $(function(arg, send) {
        var interval, match, name, range, type;
        range = arg[0], type = arg[1], name = arg[2];
        if ((match = range.match(extras_range_pattern)) == null) {
          return send.error(new Error("illegal line format; expected range, found " + (rpr(range))));
        }
        interval = interval_from_range_match(S, match);
        return send([interval, type, name]);
      });
      return null;
    };
  })(this);

  this.read_rsgs_and_block_names = function(S, handler) {
    var input, path;
    path = resolve_extras('rsgs.txt');
    input = D.new_stream({
      path: path
    });
    S.interval_by_rsgs = {};
    input.pipe(this.$split_multi_blank_sv(S)).pipe($((function(_this) {
      return function(arg) {
        var block_name, interval, rsg;
        rsg = arg[0], block_name = arg[1];
        interval = interval_from_block_name(S, rsg, block_name);
        interval['rsg'] = rsg;
        return S.interval_by_rsgs[rsg] = interval;
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.read_tags = function(S, handler) {
    var input, path;
    path = resolve_extras('tags.txt');
    input = D.new_stream({
      path: path
    });
    input.pipe(this.$split_multi_blank_sv(S)).pipe(this.$read_rsg_or_range(S)).pipe($('finish', handler));
    return null;
  };

  this.$read_rsg_or_range = (function(_this) {
    return function(S) {
      if (S.recycle_intervals) {

        /* When recycling intervals, tags for those intervals that are identified symbolically are added to the
        existing interval objects. When not recycling intervals, a new interval object is created for each line
        in the tagging source. This may influence how tags are resolved by `INTERVALSKIPLIST.aggregate`.
         */
        return $(function(arg, send) {
          var interval, match, rsg_or_range, tag;
          rsg_or_range = arg[0], tag = arg[1];
          if ((match = rsg_or_range.match(extras_range_pattern)) != null) {
            interval = interval_from_range_match(S, match);
            interval['tag'] = tag;
            S.intervals.push(interval);
          } else {
            interval = interval_from_rsg(S, rsg_or_range);
            append_tag(S, interval, tag);
          }
          return null;
        });
      }
      return $(function(arg, send) {
        var comment, hi, interval, lo, match, name, ref, rsg, rsg_or_range, tag;
        rsg_or_range = arg[0], tag = arg[1];
        if ((match = rsg_or_range.match(extras_range_pattern)) != null) {
          interval = interval_from_range_match(S, match);
          interval['tag'] = tag;
        } else {
          ref = interval_from_rsg(S, rsg_or_range), lo = ref.lo, hi = ref.hi, rsg = ref.rsg, name = ref.block;
          comment = "References RSG " + rsg + " (" + name + ").";
          interval = {
            lo: lo,
            hi: hi,
            comment: comment,
            tag: tag
          };
        }
        S.intervals.push(interval);
        return null;
      });
    };
  })(this);

  this.read = function(handler) {
    var S, intervals;
    intervals = [];
    S = {
      intervals: intervals
    };
    step((function(_this) {
      return function*(resume) {
        (yield _this.read_assigned_codepoints(S, resume));
        (yield _this.read_planes_and_areas(S, resume));
        (yield _this.read_block_names(S, resume));
        (yield _this.read_rsgs_and_block_names(S, resume));
        (yield _this.read_tags(S, resume));
        add_comments_to_intervals(S);
        return handler(null, S);
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=reader.js.map
