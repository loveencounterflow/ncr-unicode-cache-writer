// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, PATH, add_comments_to_intervals, alert, append_tag, badge, debug, echo, extras_range_pattern, help, info, interval_from_block_name, interval_from_range_match, interval_from_rsg, log, resolve, resolve_extras, resolve_ucd, rpr, step, ucd_range_pattern, urge, warn, whisper;

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'NCR-UNICODE-CACHE-WRITER/READER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  require('pipedreams/lib/plugin-tsv');

  step = require('coffeenode-suspend').step;

  ucd_range_pattern = /^([0-9a-f]{4,6})\.\.([0-9a-f]{4,6});[\x20\t]+(.+)$/i;

  extras_range_pattern = /^\^([0-9a-f]{1,6})(?:\.\.([0-9a-f]{1,6}))?$/i;

  resolve = function(path) {
    return PATH.resolve(__dirname, '..', path);
  };

  resolve_ucd = function(path) {
    return resolve(PATH.join('Unicode-UCD-9.0.0', path));
  };

  resolve_extras = function(path) {
    return resolve(PATH.join('extras', path));
  };

  interval_from_block_name = function(S, rsg, block_name) {
    var R;
    if ((R = S.interval_by_names[block_name]) == null) {
      throw new Error("RSG " + rsg + ": unknown Unicode block " + (rpr(block_name)));
    }
    return R;
  };

  interval_from_rsg = function(S, rsg) {
    var R;
    if ((R = S.interval_by_rsgs[rsg]) == null) {
      debug('4020', S.interval_by_rsgs);
      throw new Error("unknown RSG " + (rpr(rsg)));
    }
    return R;
  };

  add_comments_to_intervals = function(S) {
    var comment, hex, hi, i, interval, len, lo, ref, ref1;
    hex = function(n) {
      return 'U+' + n.toString(16);
    };
    ref = S.intervals;
    for (i = 0, len = ref.length; i < len; i++) {
      interval = ref[i];
      lo = interval.lo, hi = interval.hi;
      comment = (ref1 = interval['comment']) != null ? ref1 : '';
      interval['comment'] = ("(" + (hex(lo)) + ".." + (hex(hi)) + ") " + comment).trim();
    }
    return null;
  };

  interval_from_range_match = function(S, match) {
    var _, hi, hi_hex, lo, lo_hex;
    _ = match[0], lo_hex = match[1], hi_hex = match[2];
    lo = parseInt(lo_hex, 16);
    hi = (hi_hex != null) && hi_hex.length > 0 ? parseInt(hi_hex, 16) : lo;
    return {
      lo: lo,
      hi: hi
    };
  };

  append_tag = function(S, interval, tag) {
    var target;
    if ((target = interval['tag']) != null) {
      if (CND.isa_list(target)) {
        target.push(tag);
      } else {
        interval['tag'] = [target, tag];
      }
    } else {
      interval['tag'] = [tag];
    }
    return null;
  };

  this.$show = (function(_this) {
    return function(S) {
      return $(function(x) {
        return urge(JSON.stringify(x));
      });
    };
  })(this);

  this.$split_multi_blank_sv = function(S) {
    return D.$split_tsv({
      splitter: /\t{1,}|[\x20\t]{2,}/g
    });
  };

  this.read_block_names = function(S, handler) {
    var input, path, type;
    path = resolve_ucd('Blocks.txt');
    input = D.new_stream({
      path: path
    });
    type = 'block';
    S.interval_by_names = {};
    input.pipe(D.$split_tsv()).pipe(this.$block_interval_from_line(S)).pipe($((function(_this) {
      return function(interval) {
        var name;
        name = interval["" + type];
        S.interval_by_names[name] = interval;
        return S.intervals.push(interval);
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.$block_interval_from_line = (function(_this) {
    return function(S) {
      var type;
      type = 'block';
      return $(function(arg, send) {
        var _, hi, hi_hex, line, lo, lo_hex, match, name, obj, short_name;
        line = arg[0];
        match = line.match(ucd_range_pattern);
        if (match == null) {
          return send.error(new Error("not a valid line: " + (rpr(line))));
        }
        _ = match[0], lo_hex = match[1], hi_hex = match[2], short_name = match[3];
        lo = parseInt(lo_hex, 16);
        hi = parseInt(hi_hex, 16);
        name = type + ":" + short_name;
        return send((
          obj = {
            lo: lo,
            hi: hi,
            name: name,
            type: type
          },
          obj["" + type] = short_name,
          obj
        ));
      });
      return null;
    };
  })(this);

  this.read_planes_and_areas = function(S, handler) {
    var input, path;
    path = resolve_extras('planes-and-areas.txt');
    input = D.new_stream({
      path: path
    });
    input.pipe(this.$split_multi_blank_sv(S)).pipe(this.$read_target_interval(S)).pipe($((function(_this) {
      return function(arg) {
        var hi, interval, lo, name, obj, ref, short_name, type;
        (ref = arg[0], lo = ref.lo, hi = ref.hi), type = arg[1], short_name = arg[2];
        name = type + ":" + short_name;
        interval = (
          obj = {
            lo: lo,
            hi: hi,
            name: name,
            type: type
          },
          obj["" + type] = short_name,
          obj
        );
        return S.intervals.push(interval);
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.$read_target_interval = (function(_this) {
    return function(S) {
      return $(function(arg, send) {
        var interval, match, name, range, type;
        range = arg[0], type = arg[1], name = arg[2];
        if ((match = range.match(extras_range_pattern)) == null) {
          return send.error(new Error("illegal line format; expected range, found " + (rpr(range))));
        }
        interval = interval_from_range_match(S, match);
        return send([interval, type, name]);
      });
      return null;
    };
  })(this);

  this.read_rsgs_and_block_names = function(S, handler) {
    var input, path;
    path = resolve_extras('rsgs.txt');
    input = D.new_stream({
      path: path
    });
    S.interval_by_rsgs = {};
    input.pipe(this.$split_multi_blank_sv(S)).pipe($((function(_this) {
      return function(arg) {
        var block_name, interval, rsg;
        rsg = arg[0], block_name = arg[1];
        interval = interval_from_block_name(S, rsg, block_name);
        interval['rsg'] = rsg;
        return S.interval_by_rsgs[rsg] = interval;
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.read_tags = function(S, handler) {
    var input, path;
    path = resolve_extras('tags.txt');
    input = D.new_stream({
      path: path
    });
    input.pipe(this.$split_multi_blank_sv(S)).pipe(this.$read_rsg_or_range(S)).pipe($('finish', handler));
    return null;
  };

  this.$read_rsg_or_range = (function(_this) {
    return function(S) {
      if (S.recycle_intervals) {

        /* When recycling intervals, tags for those intervals that are identified symbolically are added to the
        existing interval objects. When not recycling intervals, a new interval object is created for each line
        in the tagging source. This may influence how tags are resolved by `INTERVALSKIPLIST.aggregate`.
         */
        return $(function(arg, send) {
          var interval, match, rsg_or_range, tag;
          rsg_or_range = arg[0], tag = arg[1];
          if ((match = rsg_or_range.match(extras_range_pattern)) != null) {
            interval = interval_from_range_match(S, match);
            interval['tag'] = tag;
            S.intervals.push(interval);
          } else {
            interval = interval_from_rsg(S, rsg_or_range);
            append_tag(S, interval, tag);
          }
          return null;
        });
      }
      return $(function(arg, send) {
        var comment, hi, interval, lo, match, name, ref, rsg, rsg_or_range, tag;
        rsg_or_range = arg[0], tag = arg[1];
        if ((match = rsg_or_range.match(extras_range_pattern)) != null) {
          interval = interval_from_range_match(S, match);
          interval['tag'] = tag;
        } else {
          ref = interval_from_rsg(S, rsg_or_range), lo = ref.lo, hi = ref.hi, rsg = ref.rsg, name = ref.block;
          comment = "References RSG " + rsg + " (" + name + ").";
          interval = {
            lo: lo,
            hi: hi,
            comment: comment,
            tag: tag
          };
        }
        S.intervals.push(interval);
        return null;
      });
    };
  })(this);

  this.write = function(S, handler) {
    var json, path, write_to_file;
    json = JSON.stringify(S.intervals, null, '  ');
    write_to_file = false;
    help(S.intervals.length + " intervals");
    if (write_to_file) {
      path = '/tmp/u-intervals.json';
      FS.writeFile(path, json, (function(_this) {
        return function() {
          help("written to " + path);
          return handler();
        };
      })(this));
    } else {
      echo(json);
      handler();
    }
    return null;
  };

  this.read = function(handler) {
    var S, intervals;
    intervals = [];
    S = {
      intervals: intervals
    };
    step((function(_this) {
      return function*(resume) {
        (yield _this.read_planes_and_areas(S, resume));
        (yield _this.read_block_names(S, resume));
        (yield _this.read_rsgs_and_block_names(S, resume));
        (yield _this.read_tags(S, resume));
        add_comments_to_intervals(S);
        return handler(null, S);
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=reader.js.map
