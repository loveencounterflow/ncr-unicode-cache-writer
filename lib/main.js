// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, PATH, alert, badge, debug, echo, help, info, log, resolve, resolve_ucd, rpr, step, suspend, urge, warn, whisper;

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'NCR-UNICODE-CACHE-WRITER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  require('pipedreams/lib/plugin-tsv');

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  resolve = function(path) {
    return PATH.resolve(__dirname, '..', path);
  };

  resolve_ucd = function(path) {
    return resolve(PATH.join('Unicode-UCD-9.0.0', path));
  };

  this.$show = (function(_this) {
    return function(S) {
      return $(function(x) {
        return urge(JSON.stringify(x));
      });
    };
  })(this);

  this.$block_interval_from_line = (function(_this) {
    return function(S) {
      var pattern, type;
      type = 'block';
      pattern = /^([0-9a-f]{4,6})\.\.([0-9a-f]{4,6});\s+(.+)$/i;
      return $(function(arg, send) {
        var _, hi, hi_hex, line, lo, lo_hex, match, name, obj, short_name;
        line = arg[0];
        match = line.match(pattern);
        if (match == null) {
          return send.error(new Error("not a valid line: " + (rpr(line))));
        }
        _ = match[0], lo_hex = match[1], hi_hex = match[2], short_name = match[3];
        lo = parseInt(lo_hex, 16);
        hi = parseInt(hi_hex, 16);
        name = type + ":" + short_name;
        return send((
          obj = {
            lo: lo,
            hi: hi,
            name: name,
            type: type
          },
          obj["" + type] = short_name,
          obj
        ));
      });
      return null;
    };
  })(this);

  this.read_block_names = function(S, handler) {
    var input, path;
    path = resolve_ucd('Blocks.txt');
    input = D.new_stream({
      path: path
    });
    input.pipe(D.$split_tsv()).pipe(this.$block_interval_from_line(S)).pipe(this.$show(S)).pipe($('finish', handler));
    return null;
  };

  this.main = function(handler) {
    var S;
    if (handler == null) {
      handler = null;
    }
    S = {};
    step((function(_this) {
      return function*(resume) {
        (yield _this.read_block_names(S, resume));
        if (handler != null) {
          return handler(null);
        }
      };
    })(this));
    return null;
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);

//# sourceMappingURL=main.js.map
