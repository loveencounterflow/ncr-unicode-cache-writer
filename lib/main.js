// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, PATH, alert, append_tag, badge, debug, echo, extras_range_pattern, help, info, interval_from_block_name, interval_from_range_match, interval_from_rsg, log, resolve, resolve_extras, resolve_ucd, rpr, step, ucd_range_pattern, urge, warn, whisper;

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'NCR-UNICODE-CACHE-WRITER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  require('pipedreams/lib/plugin-tsv');

  step = require('coffeenode-suspend').step;

  ucd_range_pattern = /^([0-9a-f]{4,6})\.\.([0-9a-f]{4,6});[\x20\t]+(.+)$/i;

  extras_range_pattern = /^\^([0-9a-f]{1,6})(?:\.\.([0-9a-f]{1,6}))?$/i;

  resolve = function(path) {
    return PATH.resolve(__dirname, '..', path);
  };

  resolve_ucd = function(path) {
    return resolve(PATH.join('Unicode-UCD-9.0.0', path));
  };

  resolve_extras = function(path) {
    return resolve(PATH.join('extras', path));
  };

  interval_from_block_name = function(S, rsg, block_name) {
    var R;
    if ((R = S.interval_by_names[block_name]) == null) {
      throw new Error("RSG " + rsg + ": unknown Unicode block " + (rpr(block_name)));
    }
    return R;
  };

  interval_from_rsg = function(S, rsg) {
    var R;
    if ((R = S.interval_by_rsgs[rsg]) == null) {
      debug('4020', S.interval_by_rsgs);
      throw new Error("unknown RSG " + (rpr(rsg)));
    }
    return R;
  };

  interval_from_range_match = function(match) {
    var _, hi, hi_hex, lo, lo_hex;
    _ = match[0], lo_hex = match[1], hi_hex = match[2];
    lo = parseInt(lo_hex, 16);
    hi = (hi_hex != null) && hi_hex.length > 0 ? parseInt(hi_hex, 16) : lo;
    return {
      lo: lo,
      hi: hi
    };
  };

  append_tag = function(S, interval, tag) {
    var target;
    if ((target = interval['tag']) != null) {
      if (CND.isa_list(target)) {
        target.push(tag);
      } else {
        interval['tag'] = [target, tag];
      }
    } else {
      interval['tag'] = [tag];
    }
    return null;
  };

  this.$show = (function(_this) {
    return function(S) {
      return $(function(x) {
        return urge(JSON.stringify(x));
      });
    };
  })(this);

  this.$split_multi_blank_sv = function(S) {
    return D.$split_tsv({
      splitter: /\t{1,}|[\x20\t]{2,}/g
    });
  };

  this.read_block_names = function(S, handler) {
    var input, path, type;
    path = resolve_ucd('Blocks.txt');
    input = D.new_stream({
      path: path
    });
    type = 'block';
    S.interval_by_names = {};
    input.pipe(D.$split_tsv()).pipe(this.$block_interval_from_line(S)).pipe($((function(_this) {
      return function(interval) {
        var name;
        name = interval["" + type];
        S.interval_by_names[name] = interval;
        return S.intervals.push(interval);
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.$block_interval_from_line = (function(_this) {
    return function(S) {
      var type;
      type = 'block';
      return $(function(arg, send) {
        var _, hi, hi_hex, line, lo, lo_hex, match, name, obj, short_name;
        line = arg[0];
        match = line.match(ucd_range_pattern);
        if (match == null) {
          return send.error(new Error("not a valid line: " + (rpr(line))));
        }
        _ = match[0], lo_hex = match[1], hi_hex = match[2], short_name = match[3];
        lo = parseInt(lo_hex, 16);
        hi = parseInt(hi_hex, 16);
        name = type + ":" + short_name;
        return send((
          obj = {
            lo: lo,
            hi: hi,
            name: name,
            type: type
          },
          obj["" + type] = short_name,
          obj
        ));
      });
      return null;
    };
  })(this);

  this.read_planes_and_areas = function(S, handler) {
    var input, path;
    path = resolve_extras('planes-and-areas.txt');
    input = D.new_stream({
      path: path
    });
    input.pipe(this.$split_multi_blank_sv(S)).pipe(this.$read_target_interval(S)).pipe($((function(_this) {
      return function(arg) {
        var hi, interval, lo, name, obj, ref, short_name, type;
        (ref = arg[0], lo = ref.lo, hi = ref.hi), type = arg[1], short_name = arg[2];
        name = type + ":" + short_name;
        interval = (
          obj = {
            lo: lo,
            hi: hi,
            name: name,
            type: type
          },
          obj["" + type] = short_name,
          obj
        );
        return S.intervals.push(interval);
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.$read_target_interval = (function(_this) {
    return function(S) {
      return $(function(arg, send) {
        var interval, match, name, range, type;
        range = arg[0], type = arg[1], name = arg[2];
        if ((match = range.match(extras_range_pattern)) == null) {
          return send.error(new Error("illegal line format; expected range, found " + (rpr(range))));
        }
        interval = interval_from_range_match(match);
        return send([interval, type, name]);
      });
      return null;
    };
  })(this);

  this.read_rsgs_and_block_names = function(S, handler) {
    var input, path;
    path = resolve_extras('rsgs.txt');
    input = D.new_stream({
      path: path
    });
    S.interval_by_rsgs = {};
    input.pipe(this.$split_multi_blank_sv(S)).pipe($((function(_this) {
      return function(arg) {
        var block_name, interval, rsg;
        rsg = arg[0], block_name = arg[1];
        interval = interval_from_block_name(S, rsg, block_name);
        interval['rsg'] = rsg;
        return S.interval_by_rsgs[rsg] = interval;
      };
    })(this))).pipe($('finish', handler));
    return null;
  };

  this.read_tags = function(S, handler) {
    var input, path;
    path = resolve_extras('tags.txt');
    input = D.new_stream({
      path: path
    });
    input.pipe(this.$split_multi_blank_sv(S)).pipe(this.$read_rsg_or_range(S)).pipe($('finish', handler));
    return null;
  };

  this.$read_rsg_or_range = (function(_this) {
    return function(S) {
      return $(function(arg, send) {
        var interval, match, rsg_or_range, tag;
        rsg_or_range = arg[0], tag = arg[1];
        if ((match = rsg_or_range.match(extras_range_pattern)) != null) {
          interval = interval_from_range_match(match);
          interval['tag'] = tag;
          return S.intervals.push(interval);
        } else {
          interval = interval_from_rsg(S, rsg_or_range);
          return append_tag(S, interval, tag);
        }
      });
      return null;
    };
  })(this);

  this.write = function(S, handler) {
    var json, path;
    path = '/tmp/u-intervals.json';
    json = JSON.stringify(S.intervals, null, '  ');
    FS.writeFile(path, json, (function(_this) {
      return function() {
        help("output written to " + path);
        return handler();
      };
    })(this));
    return null;
  };

  this.main = function(handler) {
    var S;
    if (handler == null) {
      handler = null;
    }
    S = {
      intervals: []
    };
    step((function(_this) {
      return function*(resume) {
        (yield _this.read_planes_and_areas(S, resume));
        (yield _this.read_block_names(S, resume));
        (yield _this.read_rsgs_and_block_names(S, resume));
        (yield _this.read_tags(S, resume));
        (yield _this.write(S, resume));
        if (handler != null) {
          return setImmediate((function() {
            return handler(null);
          }));
        }
      };
    })(this));
    return null;
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);

//# sourceMappingURL=main.js.map
